# Flutter client tests

Ты работаешь только с Flutter‑клиентом этого проекта.  
Игнорируй backend, FastAPI, админку и все несвязанные части.

## Цель команды

1. Проанализировать существующие тесты Flutter (unit, widget, integration).
2. Найти важные участки кода без тестов.
3. Сгенерировать недостающие тесты.
4. Улучшить и дополнить уже существующие тесты, не ломая их публичный API.

## Контекст проекта

- Язык: Dart.
- Фреймворк: Flutter.
- Тестовый стек:
  - `flutter_test` для unit и widget тестов.
  - При наличии – `integration_test` для интеграционных тестов.
- Структура (может отличаться, но ориентируйся на это по умолчанию):
  - `lib/` — исходный код приложения.
  - `test/` — unit и widget тесты.
  - `integration_test/` — интеграционные тесты.

Если структура отличается, сначала определи её по проекту и адаптируй свои действия.

## Что нужно сделать

1. **Сканирование тестов**
   - Найди все файлы тестов в `test/` и `integration_test/`.
   - Кратко опиши, какие модули/виджеты уже покрыты тестами, а какие — нет.
   - Определи критичные области кода без тестов:
     - бизнес‑логика (state management, сервисы, репозитории),
     - ключевые виджеты (экраны чатов, авторизация, экран звонка, список диалогов),
     - навигация и обработка ошибок.

2. **План тестового покрытия**
   - Сформируй список приоритетов: что тестировать в первую очередь.
   - Разбей на категории:
     - Unit‑тесты (чистая логика, форматирование данных, парсинг, валидация, state‑классы).
     - Widget‑тесты (отображение UI, реакции на действия пользователя, состояния загрузки/ошибок).
     - Интеграционные тесты (основные пользовательские сценарии, если уже используется `integration_test`).

3. **Генерация новых тестов**
   - Для каждого важного модуля/виджета без тестов:
     - Создай новые файлы в `test/` с понятными именами.
     - Пиши тесты с учётом лучших практик Flutter‑тестирования:
       - Используй `test()` и `group()` для логики.
       - Для виджетов используй `testWidgets()` с `pumpWidget`, `find`, `tap`, `pump`, проверкой состояний и текста.
       - При необходимости предлагай мокирование зависимостей (`mockito` или аналог, если уже используется).
   - Старайся покрывать:
     - “счастливый путь”,
     - граничные кейсы,
     - ошибки и исключения.

4. **Улучшение существующих тестов**
   - Пересмотри уже имеющиеся тесты:
     - Убери дублирование.
     - Добавь недостающие ассерты.
     - Покрой дополнительные состояния (loading, error, empty).
   - Если видишь “хрупкие” тесты (жёстко привязаны к неважным деталям UI), предложи рефакторинг:
     - стабилизируй селекторы (используй `Key`, важный текст и семантику вместо внутренних деталей верстки),
     - раздели слишком большие тесты на несколько более узких.

5. **Запуск и фиксы**
   - Сформируй команды для запуска тестов:
     - `flutter test` для unit и widget тестов.
     - `flutter test integration_test/...` для интеграционных, если есть.
   - Если возможны падения тестов после изменений, опиши, какие изменения в коде приложения могут понадобиться для их починки (но не меняй бизнес‑логику без явного запроса).

## Формат ответа

Отвечай по шагам:

1. Краткий обзор текущего покрытия тестами.
2. Список приоритетных зон без тестов.
3. Патчи (diff) с новыми тестовыми файлами и расширением существующих тестов.
4. Инструкции по запуску тестов и, при необходимости, рекомендации по интеграции в CI.

Соблюдай существующий стиль кода и форматирование тестов в этом проекте.