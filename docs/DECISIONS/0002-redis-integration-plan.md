# ADR-0002: План интеграции Redis в проект Orpheus

## Контекст
В проекте Orpheus используется сервер на FastAPI с PostgreSQL для хранения данных. Сейчас все активные соединения WebSocket хранятся в памяти (`ConnectionManager`), проверки лицензий идут напрямую в БД, а офлайн-сообщения хранятся в PostgreSQL. При масштабировании и росте нагрузки это создаст проблемы.

## Анализ текущей архитектуры

### Текущие узкие места:
1. **WebSocket соединения в памяти** (`ConnectionManager.active_connections`)
   - При рестарте сервера все соединения теряются
   - Невозможно масштабировать горизонтально (несколько инстансов сервера)
   - Нет возможности синхронизировать соединения между инстансами

2. **Проверки лицензий через PostgreSQL**
   - Каждый запрос идет в БД (latency)
   - Нет кэширования результатов
   - Лишняя нагрузка на БД при частых проверках

3. **Офлайн-сообщения в PostgreSQL**
   - PostgreSQL не оптимален для временных данных с TTL
   - Нет автоматического удаления по истечении срока
   - Лишняя нагрузка на основную БД

4. **FCM токены в PostgreSQL**
   - Частые обновления токенов создают нагрузку
   - Нет кэширования активных токенов

5. **Payment watcher**
   - Опрашивает все активные сессии каждые 60 секунд
   - Нет кэширования результатов проверок баланса
   - При большом количестве сессий создаст нагрузку

## Где Redis может улучшить проект

### 1. Управление WebSocket соединениями (Приоритет: ВЫСОКИЙ)
**Проблема:** Соединения хранятся в памяти, не масштабируются.

**Решение с Redis:**
- Использовать Redis для хранения метаданных активных соединений
- Ключ: `ws:connection:{pubkey}` → значение: `{instance_id, connected_at, last_ping}`
- TTL: 60 секунд (обновляется при каждом ping)
- Pub/Sub для синхронизации между инстансами сервера

**Выгоды:**
- Горизонтальное масштабирование (несколько инстансов FastAPI)
- Отказоустойчивость (при падении инстанса соединения видны другим)
- Мониторинг активных соединений в реальном времени

**Реализация:**
```python
# Псевдокод
redis.setex(f"ws:connection:{pubkey}", 60, json.dumps({
    "instance_id": INSTANCE_ID,
    "connected_at": datetime.utcnow().isoformat()
}))
```

### 2. Кэширование проверок лицензий (Приоритет: ВЫСОКИЙ)
**Проблема:** Каждая проверка лицензии идет в PostgreSQL.

**Решение с Redis:**
- Кэш: `license:{pubkey}` → `"active"` или `"inactive"` (TTL: 1 час)
- При изменении лицензии инвалидировать кэш
- Fallback на PostgreSQL при cache miss

**Выгоды:**
- Снижение нагрузки на PostgreSQL на 80-90%
- Уменьшение latency проверок лицензий с ~10-50ms до ~1-2ms
- Масштабируемость при росте пользователей

**Реализация:**
```python
# Псевдокод
cached = redis.get(f"license:{pubkey}")
if cached:
    return cached == "active"
# Fallback to PostgreSQL
has_license = await check_license_db(pubkey)
redis.setex(f"license:{pubkey}", 3600, "active" if has_license else "inactive")
```

### 3. Офлайн-сообщения через Redis (Приоритет: СРЕДНИЙ)
**Проблема:** PostgreSQL не оптимален для временных данных с TTL.

**Решение с Redis:**
- Использовать Redis Lists или Streams для офлайн-сообщений
- Ключ: `offline:msg:{recipient_pubkey}` → список сообщений
- TTL: 7 дней (автоматическое удаление)
- При доставке удалять из Redis

**Выгоды:**
- Автоматическое удаление старых сообщений (TTL)
- Быстрая доставка при подключении (O(1) операции)
- Меньше нагрузки на PostgreSQL

**Альтернатива:** Оставить в PostgreSQL, но добавить Redis для кэширования "есть ли офлайн-сообщения" (флаг `offline:has:{pubkey}`).

### 4. Кэширование FCM токенов (Приоритет: СРЕДНИЙ)
**Проблема:** Частые обновления токенов создают нагрузку на PostgreSQL.

**Решение с Redis:**
- Кэш: `fcm:token:{pubkey}` → FCM токен (TTL: 30 дней)
- При обновлении обновлять и Redis, и PostgreSQL
- Использовать Redis для быстрого доступа при отправке push

**Выгоды:**
- Быстрый доступ к токенам при отправке push-уведомлений
- Снижение нагрузки на PostgreSQL

### 5. Rate Limiting (Приоритет: ВЫСОКИЙ)
**Проблема:** Нет защиты от спама и злоупотреблений.

**Решение с Redis:**
- Использовать Redis для rate limiting (sliding window или token bucket)
- Ключ: `rate:limit:{pubkey}:{action}` → счетчик
- Ограничения:
  - Отправка сообщений: 100/минуту
  - Создание звонков: 10/минуту
  - Проверка лицензий: 50/минуту

**Выгоды:**
- Защита от спама и DDoS
- Защита от злоупотреблений API
- Гибкая настройка лимитов

### 6. Кэширование статусов платежей (Приоритет: НИЗКИЙ)
**Проблема:** Payment watcher опрашивает все сессии каждые 60 секунд.

**Решение с Redis:**
- Кэш результатов проверки баланса: `payment:balance:{address}` → баланс (TTL: 30 секунд)
- Снизить частоту опроса для адресов с кэшированным балансом

**Выгоды:**
- Меньше запросов к TronGrid API
- Снижение нагрузки на внешний API

### 7. Pub/Sub для масштабирования (Приоритет: СРЕДНИЙ)
**Проблема:** При нескольких инстансах сервера нужно синхронизировать события.

**Решение с Redis:**
- Использовать Redis Pub/Sub для событий:
  - `channel:license:updated` - обновление лицензии
  - `channel:message:send` - отправка сообщения (для балансировки)
  - `channel:call:offer` - входящий звонок

**Выгоды:**
- Синхронизация между инстансами
- Балансировка нагрузки
- Real-time события

## План внедрения (Roadmap)

### Фаза 1: Критичные улучшения (v1.1.0)
1. ✅ Кэширование проверок лицензий
2. ✅ Rate limiting для защиты от спама
3. ✅ Кэширование FCM токенов

**Оценка:** 2-3 дня разработки

### Фаза 2: Масштабирование (v1.2.0)
4. ✅ Управление WebSocket соединениями через Redis
5. ✅ Pub/Sub для синхронизации между инстансами
6. ✅ Миграция офлайн-сообщений в Redis (опционально)

**Оценка:** 3-5 дней разработки

### Фаза 3: Оптимизация (v1.3.0+)
7. ✅ Кэширование статусов платежей
8. ✅ Мониторинг и метрики через Redis

**Оценка:** 1-2 дня разработки

## Технические детали

### Зависимости
- `redis` (Python) или `aioredis` для async операций
- `redis-py` для синхронных операций (если нужно)

### Конфигурация
```python
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")
REDIS_PASSWORD = os.getenv("REDIS_PASSWORD", None)
```

### Структура ключей Redis
```
ws:connection:{pubkey}          # WebSocket соединения (TTL: 60s)
license:{pubkey}                # Кэш лицензий (TTL: 1h)
fcm:token:{pubkey}              # FCM токены (TTL: 30d)
offline:msg:{pubkey}            # Офлайн-сообщения (TTL: 7d)
offline:has:{pubkey}            # Флаг наличия офлайн-сообщений (TTL: 7d)
rate:limit:{pubkey}:{action}    # Rate limiting (TTL: 60s)
payment:balance:{address}       # Кэш балансов (TTL: 30s)
```

### Миграция
1. Добавить Redis как опциональную зависимость (graceful degradation)
2. Постепенная миграция компонентов
3. Fallback на PostgreSQL при недоступности Redis
4. Мониторинг использования Redis

## Риски и митигация

### Риск 1: Redis недоступен
**Митигация:** Graceful degradation - fallback на PostgreSQL, логирование ошибок

### Риск 2: Потеря данных при рестарте Redis
**Митигация:** Redis используется только для кэша и временных данных. Критичные данные остаются в PostgreSQL.

### Риск 3: Увеличение сложности
**Митигация:** Инкапсулировать Redis логику в отдельные сервисы, добавить тесты

## Метрики успеха

- Снижение latency проверок лицензий на 80%+
- Снижение нагрузки на PostgreSQL на 50%+
- Возможность горизонтального масштабирования (несколько инстансов)
- Защита от спама через rate limiting

## Решение
Начать с Фазы 1 (кэширование лицензий, rate limiting, FCM токены) в версии 1.1.0. Это даст максимальный эффект при минимальных изменениях архитектуры.

